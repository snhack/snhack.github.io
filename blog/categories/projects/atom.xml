<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projects | Swindon Hackspace]]></title>
  <link href="http://swindon.hackspace.org.uk/blog/categories/projects/atom.xml" rel="self"/>
  <link href="http://swindon.hackspace.org.uk/"/>
  <updated>2015-08-23T13:40:06+01:00</updated>
  <id>http://swindon.hackspace.org.uk/</id>
  <author>
    <name><![CDATA[Swindon Hackspace]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Liquid Tape vs a Pi Camera Lead]]></title>
    <link href="http://swindon.hackspace.org.uk/blog/liquid-tape-vs-a-round-raspberry-pi-camera-lead/"/>
    <updated>2014-11-11T17:08:00+00:00</updated>
    <id>http://swindon.hackspace.org.uk/blog/liquid-tape-vs-a-round-raspberry-pi-camera-lead</id>
    <content type="html"><![CDATA[
<p>A while back I was watching either a YouTube video or reading a
blog post about soldering wires onto PCBs, possibly a quadcopter power
distribution board.  After soldering, the guy got out something called
liquid electrical tape and gobbed some over the solder joints to
reinforce them.  Brilliant I thought!  Why have I never head of this
stuff before?  I usually use the hot glue gun for things like that,
but somehow this looked better and neater.</p>

<!-- more -->

<p>So I promptly got on Google and looked into this stuff. There
were a few different manufacturers and it wasn’t that
cheap, so I nearly didn’t buy any because I didn’t have a specific use
for it at the time.  But in the end I thought what the heck and
ordered some from <a href="http://www.amazon.co.uk/gp/product/B000LNKIFS">Amazon</a>.</p>

<p><img src="liquidTapeBottle.jpg" alt="Liquid Electrical Tape" /></p>

<p>It arrived, I opened it, looked at the bottle of black gooey tar-like
liquid, went “mmm, nice”, didn’t really have a use for it and so it
sat on my desk unused.  </p>

<p>Until now! </p>

<h2 id="enter-the-round-raspberry-pi-camera-extension-cable">Enter the Round Raspberry Pi Camera Extension Cable.</h2>

<p>I’ve been meaning to fit a camera to my 3D printer’s Raspberry Pi and
<a href="/blog/octoprint-and-the-raspberry-pi-camera/">hook it into OctoPrint</a>
since I got the printer, and I finally got round to getting a camera.  The 
cable  that comes with it however, is flat and woefully short.  Not great 
for routing around to get the camera into the ideal location.  I’d looked 
for round cables in the past with no joy, but was pleased to find that 
someone was now selling them on <a href="http://stores.ebay.co.uk/picables">eBay</a>.</p>

<p>As it arrives it’s a bit “diy” to say the least, but that’s okay. What
you get is a cable with a plug on each end and a socket that looks
like it should be mounted onto a PCB.
Plugging the plug part into the back of the PCB socket and connecting
up the camera proved that it worked fine, however the connection
wasn’t at all secure and any movement of the camera or cable caused it
to stop working, requiring a reboot of the Pi to get it going again.</p>

<p>That wasn’t going to be very good, since I was planning on mounting the
camera on my printbed which moves back and forth.  I thought about heat 
shrinking the connection to reinforce it, but
realised it was a perfect opportunity to try out the liquid 
tape that had been sitting on my desk for quite a few weeks now.</p>

<p><img src="brushingOn.jpg" alt="Brushing On" /></p>

<p>Knowing that the cable was working, I supported it on my desk with
some helping hands and a random heat sink that was lying around, then
started to apply the black goo from the bottle using the brush
attached to the inside of the lid.</p>

<p><img src="halfDone.jpg" alt="Half Done" /></p>

<p>I applied plenty so as to cover the whole of the PCB socket; all the
time hoping this worked, because it wasn’t going to come apart again
without making some serious mess and probably ruining the cable.</p>

<p><img src="oneCoatVsTwo.jpg" alt="One Coat vs Two" /></p>

<p>It took a couple of coats to get a good covering (that’s what it 
recommends on the bottle).  The goo seemed to shrink slightly as it 
dried and formed a nice tight rubbery seal around the connection.</p>

<p><img src="completedProduct.jpg" alt="Finished Cable" /></p>

<p>The finished seal looks pretty tidy, probably more tidy than if I’d
used heat shrink. The cable still works and the camera can be moved
around without loosing its connection to the Raspberry Pi. Success!</p>

<p>So, if you enjoy messing around with black goo, enjoy the smell of strong 
solvent and have some electrical connections that need sealing or 
reinforcing, I can highly recommend using some liquid electrical tape.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PiFace Shutdown Message]]></title>
    <link href="http://swindon.hackspace.org.uk/blog/piface-shutdown-message/"/>
    <updated>2014-06-03T17:13:00+01:00</updated>
    <id>http://swindon.hackspace.org.uk/blog/piface-shutdown-message</id>
    <content type="html"><![CDATA[<p>If you’re running your Raspberry Pi in a headless mode, sometimes it’s hard to know 
when shutdown is complete and it’s safe to turn off the power. If you have a 
<a href="http://uk.farnell.com/piface/piface-control-display/i-o-board-with-lcd-display-for/dp/2344458">PiFace</a>
you could use that to display a message when shutdown is complete.  In this article 
we’ll see how to do just that.</p>

<!-- more -->

<h3 id="the-message">The Message</h3>

<p>First of all, let’s create a python script to display a message on the PiFace. 
Check out my previous post on <a href="/blog/piface-control-and-display-board/">getting started with the PiFace</a>
for more details on exactly how to do this.</p>

<p>This is the script I’ll be using, it displays the Swindon Hackspace logo and
a simple message.</p>

<p>```py
import pifacecad as p</p>

<p>cad = p.PiFaceCAD()
cad.lcd.backlight_on()
cad.lcd.cursor_off()
cad.lcd.blink_off()</p>

<p>cad.lcd.set_cursor(5,0)
cad.lcd.write(“Shutdown”)
cad.lcd.set_cursor(5,1)
cad.lcd.write(“Complete”)</p>

<p>sh = p.LCDBitmap([3,7,14,12,24,24,31,31])
cad.lcd.store_custom_bitmap(0, sh)
sh = p.LCDBitmap([31,31,0,27,27,27,31,31])
cad.lcd.store_custom_bitmap(1, sh)
sh = p.LCDBitmap([24,28,14,7,3,0,0,0])
cad.lcd.store_custom_bitmap(2, sh)
sh = p.LCDBitmap([0,0,0,24,28,14,7,3])
cad.lcd.store_custom_bitmap(3, sh)
sh = p.LCDBitmap([31,31,27,27,27,0,31,31])
cad.lcd.store_custom_bitmap(4, sh)
sh = p.LCDBitmap([31,31,3,3,6,14,28,24])
cad.lcd.store_custom_bitmap(5, sh)</p>

<p>cad.lcd.set_cursor(1,0)
cad.lcd.write_custom_bitmap(0)
cad.lcd.write_custom_bitmap(1)
cad.lcd.write_custom_bitmap(2)
cad.lcd.set_cursor(1,1)
cad.lcd.write_custom_bitmap(3)
cad.lcd.write_custom_bitmap(4)
cad.lcd.write_custom_bitmap(5)
```</p>

<p>Test that your script works by running it now: <code>python3 ShutdownMessage.py</code></p>

<h3 id="getting-the-script-to-run-on-shutdown">Getting the Script to Run on Shutdown</h3>

<p>The Linux rc system controls what services and processes run at boot time and at 
shutdown. It’s fairly easy to insert a small script into the startup sequence 
because you can simply add it to <code>rc.local</code>, however there is no equivalent for 
shutdown.</p>

<p>We will need to create ourselves a fully fledged init script.  This will live 
in <code>/etc/init.d/</code>.  If you have installed the PiFace package on your Raspberry Pi 
you should already have one in there called <code>pifacecadsysinfo</code> which you can configure 
to run at startup to display system info (CPU temperatures, etc).  This will be a 
good starting point for our shutdown script.  Make a copy of it and call it <code>pifaceshutdown</code>.</p>

<p><code>sh
sudo cp /etc/init.d/pifacecadsysinfo /etc/init.d/pifaceshutdown 
</code></p>

<p>Open it up in your favourite editor, since it is in the <code>etc</code> folder you’ll need 
to be root to be allowed to save changes, so I use this:</p>

<p><code>sh
sudoedit /etc/init.d/pifaceshutdown
</code></p>

<p>Looking at the structure of the script there are a few points of interest.  The header 
at the top defines some parameters used by the init system to determine script order, 
more on that later. </p>

<p>For now I’m interested in the start and stop functions.  The <code>stop()</code> function is where 
we need to call our script.  We can take the code currently in the <code>start()</code> function and 
use that as a basis of our <code>stop()</code> function.  We don’t need all that stuff about tracking 
the process identifier so just copy the call to python.</p>

<p><code>sh
stop() {
        echo -n "Displaying PiFace CAD shutdown message: "
        /usr/bin/python3 $SCRIPT_FILE
        echo "[Complete]"
}
</code></p>

<p>Make sure to change the value of the <code>SCRIPT_FILE</code> variable towards the start of the 
script to point to wherever you saved your python script.  I saved mine in the home 
directory under a <code>piface</code> folder.  You’ll need to specify the full path here.</p>

<p><code>sh
SCRIPT_FILE="/home/pi/piface/ShutdownMessage.py"
</code></p>

<p>We don’t want to do anything on start in this script (we could display a startup message of 
course), so clear out that method and just replace it with a friendly message that will be 
printed out to the console.</p>

<p><code>sh
start() {
        echo "PiFace CAD shutdown message no action on start"
}
</code></p>

<h3 id="the-tricky-bit">The Tricky Bit</h3>

<p>The whole idea of this is to try and give us an indication that it’s safe to disconnect 
the power, so we want our script to run as late as possible in the shutdown sequence.</p>

<p>Linux startup and shutdown is controlled by scripts which are run as part of
run-levels.  There is more info <a href="http://www.debian.org/doc/debian-policy/ch-opersys.html#s-sysvinit">here</a>
but for now all we need to know is that runlevel zero specifies 
scripts to run at shutdown. The scripts live in <code>/etc/init.d</code> and from there they
are linked to directories <code>/etc/rc0.d</code>, <code>/etc/rc1.d</code>, etc, one for each run-level.</p>

<p>We can see which scripts are currently configured to run at shutdown by looking in 
<code>/etc/rc0.d</code>.  These scripts will be run in order when the system shuts down. ‘K’ means
kill and the two digit number is used to provide the order.  For scripts with the same
number it isn’t really defined what the exact order is, the implication being that it
isn’t really important.  Some Linux init systems will try to run scripts in parallel in
order to speed up the process.</p>

<p><code>sh
pi@raspberrypi ~ $ ls -l /etc/rc0.d/
total 4
lrwxrwxrwx 1 root root  22 Feb  9  2013 K01fake-hwclock -&gt; ../init.d/fake-hwclock
lrwxrwxrwx 1 root root  17 Feb  9  2013 K01ifplugd -&gt; ../init.d/ifplugd
lrwxrwxrwx 1 root root  17 Feb  9  2013 K01lightdm -&gt; ../init.d/lightdm
lrwxrwxrwx 1 root root  14 May  3 19:48 K01lirc -&gt; ../init.d/lirc
lrwxrwxrwx 1 root root  18 Feb  9  2013 K01plymouth -&gt; ../init.d/plymouth
lrwxrwxrwx 1 root root  24 Apr 21  2013 K01tightvncserver -&gt; ../init.d/tightvncserver
lrwxrwxrwx 1 root root  22 Feb  9  2013 K01triggerhappy -&gt; ../init.d/triggerhappy
lrwxrwxrwx 1 root root  17 Feb  9  2013 K01urandom -&gt; ../init.d/urandom
lrwxrwxrwx 1 root root  20 Apr 21  2013 K02alsa-utils -&gt; ../init.d/alsa-utils
lrwxrwxrwx 1 root root  18 Apr 21  2013 K03sendsigs -&gt; ../init.d/sendsigs
lrwxrwxrwx 1 root root  17 Apr 21  2013 K04rsyslog -&gt; ../init.d/rsyslog
lrwxrwxrwx 1 root root  22 Apr 21  2013 K05umountnfs.sh -&gt; ../init.d/umountnfs.sh
lrwxrwxrwx 1 root root  20 Apr 21  2013 K06nfs-common -&gt; ../init.d/nfs-common
lrwxrwxrwx 1 root root  17 Apr 21  2013 K06rpcbind -&gt; ../init.d/rpcbind
lrwxrwxrwx 1 root root  20 Apr 21  2013 K07hwclock.sh -&gt; ../init.d/hwclock.sh
lrwxrwxrwx 1 root root  20 Apr 21  2013 K07networking -&gt; ../init.d/networking
lrwxrwxrwx 1 root root  18 Apr 21  2013 K08umountfs -&gt; ../init.d/umountfs
lrwxrwxrwx 1 root root  20 Apr 21  2013 K09umountroot -&gt; ../init.d/umountroot
lrwxrwxrwx 1 root root  14 Apr 21  2013 K10halt -&gt; ../init.d/halt
</code></p>

<p>It looks pretty easy to add our script using the <code>update-rc.d</code> command:</p>

<p><code>
usage: update-rc.d [-n] [-f] &lt;basename&gt; remove
       update-rc.d [-n] &lt;basename&gt; defaults [NN | SS KK]
       update-rc.d [-n] &lt;basename&gt; start|stop NN runlvl [runlvl] [...] .
       update-rc.d [-n] &lt;basename&gt; disable|enable [S|2|3|4|5]
                -n: not really
                -f: force
</code></p>

<p>We need to give it the name of our script <code>&lt;basename&gt;</code>, what we want to do (start or stop), 
the number to run as (NN) and the run-level to add it to.  This should work then,
we’ll choose <code>NN = 99</code> to make sure it runs last.</p>

<p><code>sh
pi@raspberrypi ~ $ sudo update-rc.d pifaceshutdown stop 99 0 .
update-rc.d: using dependency based boot sequencing
</code></p>

<p>Unfortunately it seems to have ignored the <code>NN</code> parameter and puts our script
fairly early on in the sequence:</p>

<p><code>sh
pi@raspberrypi ~ $ ls /etc/rc0.d/*pifaceshutdown
/etc/rc0.d/K01pifaceshutdown
</code></p>

<p>This probably wouldn’t matter for many scripts, but we want this to run as
near to last as possible so that once the message is displayed we know it’s
okay to disconnect the power.  So we’ll have to do something else.</p>

<p>Notice the output we got from <code>update-rc.d</code>, it said “using dependency based 
boot sequencing”.  That header in the init script we saw earlier is important.
It looks a bit like a big comment (‘#’ is used to indicate a line is a comment
in many linux scripts and some programming languages).</p>

<p><code>
### BEGIN INIT INFO
# Provides: pifacecadsysinfo
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start pifacecad status daemon at boot time.
# Description:       Start pifacecad status daemon at boot time.
### END INIT INFO
</code></p>

<p>Looks like we’d better update this.  First off, it would be polite to update the 
descriptions, so do that.</p>

<p><code>Default-Start</code> and <code>Default-Stop</code> look like they give a hint to which run-levels 
our script should be in by default, so let’s clear out <code>Default-Start</code> and set 
<code>Default-Stop</code> to just include run level zero (shutdown).  Note that run-level 
one is single-user mode,  generally only used by sysadmins for doing system 
maintenance or when you have a serious problem, and run-level six is used for reboot.</p>

<p>The remaining three parameters look like they have something to do with the order
in which the scripts are run.  <code>Required-Start</code> and <code>Required-Stop</code> look like 
they control the order of starting and stopping services.  We aren’t fussed about 
start-up so clear this out.  </p>

<p>At this point I’m going to skip a bit of trial and error I did while I played around 
with various values in <code>Required-Stop</code> option, but let’s just say that nothing I tried 
made much difference.  The values you can use in this option are the name of another 
init script, or a few special values (such as <code>$syslog</code>) which are defined in the 
<a href="https://wiki.debian.org/LSBInitScripts">documentation</a>.</p>

<p>Eventually I abandoned trying to make <code>Required-Stop</code> work and noticed an option that
wasn’t in the original script we copied called <code>X-Stop-After</code>.  This makes much more 
sense and does what it says on the tin - stop this script after some other.</p>

<p>Looking at the scripts that run in our current shutdown sequence (above) the last
few are <code>K08umountfs</code>, <code>K09umountroot</code> and <code>K10halt</code>.  We can’t stop after <code>halt</code>
because the system will be halted at that time.  I tried stopping after <code>unmountroot</code>
which nearly worked, but it didn’t quite have time to complete drawing the entire display
before the system halted so I ended up with only half a message. </p>

<p>Finally I decided on <code>X-Stop-After: umountfs</code>, which seemed to work nicely.  You may
need to experiment a little.  My header ended up looking like this:</p>

<p><code>
### BEGIN INIT INFO
# Provides: pifaceshutdown
# Required-Start:
# Required-Stop:
# X-Stop-After:      umountfs
# Default-Start:
# Default-Stop:      0
# Short-Description: Displays a shutdown message on the PiFace.
# Description:       Displays a shutdown message on the PiFace.
### END INIT INFO
</code></p>

<p>Finally, re-add the script to run-level zero and check it worked.</p>

<p>```
pi@raspberrypi ~ $ sudo update-rc.d pifaceshutdown stop 99 0 .
update-rc.d: using dependency based boot sequencing</p>

<p>pi@raspberrypi ~ $ ls /etc/rc0.d/*pifaceshutdown
/etc/rc0.d/K09pifaceshutdown
```</p>

<p>Much better!  Make sure to clear the PiFace if it’s still showing the 
shutdown message from our earlier test (or you won’t know if it’s worked
or not), then shutdown your Raspberry Pi.  It doesn’t matter how you shutdown,
I usually use the command line <code>sudo shutdown now -h</code>.</p>

<p><img src="piface-shutdown.jpg" alt="PiFace Shutdown" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octoprint and the Raspberry Pi Camera Module]]></title>
    <link href="http://swindon.hackspace.org.uk/blog/octoprint-and-the-raspberry-pi-camera/"/>
    <updated>2014-05-19T14:20:00+01:00</updated>
    <id>http://swindon.hackspace.org.uk/blog/octoprint-and-the-raspberry-pi-camera</id>
    <content type="html"><![CDATA[<p>The Hackspace recently took delivery of a Raspberry Pi NoIR Camera Module from 
<a href="http://uk.farnell.com/">Farnell</a> - full details are on <a href="http://uk.farnell.com/raspberry-pi/rpi-noir-camera-board/raspberry-pi-noir-camera-board/dp/2357308">their website</a>.
It is an add-on camera module for the Raspberry Pi which has no infrared filter, making it perfect for taking infrared photographs or photographing objects in low light (twilight) conditions. The camera plugs directly into the Pi by way of a 15 pin Ribbon Cable, to the dedicated 15 pin MIPI Camera Serial Interface (CSI). The standard ribbon cable supplied is going to be too short for our 3D printer needs, but longer ribbon cables can be purchased. The cable can easily be replaced by uncoupling at the camera end.</p>

<p><a href="12.jpg"><img src="12-sml.jpg" alt="The Pi NoIR Camera Board Box" /></a></p>

<!-- more -->

<ul>
  <li>General Specification</li>
  <li>Omnivision 5647 sensor in a fixed-focus module without IR filter</li>
  <li>5 megapixel</li>
  <li>2592×1944 stills</li>
  <li>1080p at 30 frames per second</li>
  <li>720p at 60 frames per second</li>
  <li>640x480p at 60/90 frames per second</li>
  <li>CSi interface with 150mm ribbon cable</li>
  <li>Weighs 2.4g (3.4g with ribbon cable)</li>
</ul>

<p>In this post I’ll cover what we did to get the camera module working and ready for use. There will be a follow up post which will show how we are actually using it and how the camera and Pi is fitted to the printer.</p>

<h2 id="a-bit-of-background">A Bit of Background</h2>

<p>The Hackspace already has a Raspberry Pi running as a 3D print server allowing the controlling of our Prusa Mendel through the two options of either <a href="http://octoprint.org/">Octoprint</a> or <a href="http://www.repetier.com/repetier-server-download/">Repetier Server</a>. The Pi distribution was provided by myself and is <a href="http://www.raspbian.org/">Raspbian</a> with Octoprint and Repetier Server loaded afterwards. What we need to do is add support for the RaspiCam and web video streaming. Initially to take time-lapse videos of 3D printing then moving onto other projects afterwards.</p>

<h2 id="repetier-server-or-octoprint">Repetier Server or Octoprint?</h2>

<p>The short answer for the Hackspace is both, and we use whatever our own personal preference is. Repetier Server is not to be confused with <a href="http://www.repetier.com/documentation/repetier-host/">Repetier Host</a>, which is by the same developer. Repetier Host is a full work flow solution for 3D printing to create, visualise and edit printer paths, as well as full printer control. All of this software is completely free.</p>

<p>Octoprint has built in camera support for time-lapse video or stills while printing, or even live streaming via it’s web interface. It also allows graphical visualisation of the printer extrusion paths live as they are being printed. Repetier Server does not have support for either of these although live streaming can still be accessed on port 8080 via the <a href="http://sourceforge.net/apps/mediawiki/mjpg-streamer/nfs/project/m/mj/mjpg-streamer/7/7f/Screenshot_static_example.png">mjpg-streamer web interface</a>, which gets installed as part of the set-up for the video side of things (more on that later). Repetier server has an annoying bug where after you have ran a print job, the manual extrude feature either does not work, or wants to extrude forever, resulting in a switch off and switch on solution. However, Repetier server does seem faster when uploading gcode, or when choosing to print a previously uploaded file.</p>

<p>For the purposes of this article we will be focusing on using OctoPrint, because as mentioned earlier, it has built in camera support.</p>

<h2 id="the-beginning">The Beginning</h2>

<p>To create a 3D print server on a Pi from scratch, the easiest route to follow is to download the <a href="https://github.com/guysoft/OctoPi">OctoPi</a> distribution and follow their instructions, which have everything included to get the Pi working with OctoPrint and the RaspiCam. You can then add on Repetier Server to this afterwards should you wish. Installing OctoPi would make this article end now and everything would be so straight forward.</p>

<h2 id="updating-the-raspberry-pi">Updating the Raspberry Pi</h2>

<p>It’s been some time since the Pi was updated so we thought it was best to go through this first.</p>

<p>We updated the Raspbian install on our Raspberry Pi by running :</p>

<pre><code>apt-get update &amp;&amp; apt-get upgrade
</code></pre>

<p>You may need to be root, in which case :</p>

<pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade
</code></pre>

<p>This took some hours.</p>

<h2 id="enabling-the-camera">Enabling the camera</h2>

<p>Open the <code>raspi-config</code> tool from the Terminal:</p>

<pre><code>sudo raspi-config
</code></pre>

<p>Select <code>camera</code>, then select <code>Enable</code>, and when prompted to reboot select <code>Yes</code>.</p>

<p><a href="16.png"><img src="16.png" alt="raspi-config" /></a></p>

<p>Enabling the camera using <code>raspi-config</code> did two things. It told your Pi that there is a camera attached and it added three command line utilities.</p>

<pre><code>raspistill
raspivid
raspiyuv
</code></pre>

<p>With the camera module connected and enabled, enter the following command in the Terminal to take a picture:</p>

<pre><code>raspistill -o cam.jpg
</code></pre>

<p>For more on command line usage, see : <a href="http://www.raspberrypi.org/documentation/usage/camera/raspicam/README.md">http://www.raspberrypi.org/documentation/usage/camera/raspicam/README.md</a></p>

<h2 id="installing-octoprint">Installing Octoprint</h2>

<p>If you do not have Octoprint installed and don’t fancy installing the <a href="https://github.com/guysoft/OctoPi">OctoPi</a> distribution, then maybe you would prefer to add Octoprint onto your existing Pi OS? For this I would only be repeating (and not very well) what has already been written over on the <a href="https://github.com/foosel/OctoPrint/wiki/Setup-on-a-Raspberry-Pi-running-Raspbian">OctoPrint Github Repository</a>, so check it out.</p>

<h2 id="adding-rasppicam-support-to-octoprint">Adding RaspPiCam Support to Octoprint</h2>

<p>The repository we need to download, unpack and compile is <a href="https://github.com/jacksonliam/mjpg-streamer">mjpg-streamer-experimental</a> by Liam Jackson. This has the RaspiCam plugin</p>

<p>For the compile side, we need to ensure the command <code>cmake</code> and a dev version of <code>libjpeg</code> is pre-installed:</p>

<pre><code>sudo apt-get install libjpeg62-dev
sudo apt-get install cmake
</code></pre>

<p>When prompted select <code>Y</code> to install.</p>

<pre><code>cd ~
wget https://github.com/jacksonliam/mjpg-streamer/archive/master.zip
unzip master.zip
rm master.zip
cd mjpg-streamer-master/mjpg-streamer-experimental
make clean all
</code></pre>

<p>You can run directly from the mjpg-streamer-experimental folder with:</p>

<pre><code>export LD_LIBRARY_PATH=.
./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so"
</code></pre>

<p>You can also specify options, like in <code>raspivid</code> above</p>

<pre><code>export LD_LIBRARY_PATH=.
./mjpg_streamer -o "output_http.so -w ./www" -i "input_raspicam.so -x 1280 -y 720 -fps 15 -ex night"
</code></pre>

<p>If you have followed the install guide for <a href="https://github.com/foosel/OctoPrint/wiki/Setup-on-a-Raspberry-Pi-running-Raspbian">OctoPrint</a> correctly, then you will need to make the following changes to your <a href="https://github.com/foosel/OctoPrint/wiki/Setup-on-a-Raspberry-Pi-running-Raspbian#automatic-start-up">startup script</a> to now look at this new mjpg-streamer-experimental folder:</p>

<p>Edit the <code>/home/pi/bin/octoprint</code> start up script with the following:</p>

<pre><code>#!/bin/sh
OCTOPRINT_HOME=/home/pi/OctoPrint
MJPEG_STREAMER_HOME=/home/pi/mjpg-streamer-master/mjpg-streamer-experimental
export LD_LIBRARY_PATH=$MJPEG_STREAMER_HOME

# start mjpeg streamer
$MJPEG_STREAMER_HOME/mjpg_streamer -i "$MJPEG_STREAMER_HOME/input_raspicam.so -x 1280 -y 720 -fps 15 -ex night" -o "$MJPEG_STREAMER_HOME/output_http.so -w $MJPEG_STREAMER_HOME/www" &amp;

# start the webui
$OCTOPRINT_HOME/run --daemon start
</code></pre>

<p>Hopefully that’s it, after a reboot, you should find that OctoPrint is running on the <code>http://&lt;your Raspi's IP&gt;:&lt;port number&gt;</code> you have assigned and the webcam feed from the RaspiCam is visible in the <code>Control</code> tab</p>

<p>You can see in the following photo that the infrared from a remote control can be picked up, due to this model of RaspiCam having no infrared filter.</p>

<p><a href="14.jpg"><img src="14-sml.jpg" alt="Infrared Remote" /></a></p>

<p>NOTE : You can still access the webcam stream without OctoPrint installed, in case you want to use Repetier Server instead. Just type <code>http://&lt;your Raspi's IP&gt;:8080</code> in your favourite browser.</p>

<p><a href="17.png"><img src="17.png" alt="Mjpg-Streamer" /></a></p>

<h2 id="next-steps">Next Steps</h2>

<p>We now need to design an enclosure for the Pi and PiFace, buy a longer camera ribbon connection, then find a suitable mounting position on the Prusa Mendel for it’s final resting place.</p>

<p><a href="13.jpg"><img src="13-sml.jpg" alt="3D Printer Setup" /></a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PiFace Control And Display Board]]></title>
    <link href="http://swindon.hackspace.org.uk/blog/piface-control-and-display-board/"/>
    <updated>2014-05-08T17:20:00+01:00</updated>
    <id>http://swindon.hackspace.org.uk/blog/piface-control-and-display-board</id>
    <content type="html"><![CDATA[<p>The Hackspace recently took delivery of a 
<a href="http://uk.farnell.com/piface/piface-control-display/i-o-board-with-lcd-display-for/dp/2344458">PiFace Control and Display board from Farnell</a>.
It is an add-on board for the Raspberry Pi that includes a 16 character by 2 line
display, five push buttons, a toggle button and an IR receiver.  The 
intention is to use this on the Hackspace 3D printer to display some information
about the printer (bed and extruder temperatures) and about the job (percent
complete).  It would also be nice to use the buttons to control some of the 
functions of the printer such as priming the extruder.</p>

<p>In this post I’ll cover what I did to get up and running with the PiFace.  This
was really just a learning exercise to understand how it works and what can be
done.  There will be another post about getting it working with the 3D printer
later on.</p>

<!-- more -->

<p><img src="Piface.jpg" alt="PiFace" /></p>

<h2 id="getting-the-raspberry-pi-ready">Getting The Raspberry Pi Ready</h2>

<p>There is a nice guide on getting everything setup on the <a href="http://www.piface.org.uk/guides/setting_up_pifacecad/">PiFace website</a>
so I won’t go into every detail again.  In short:</p>

<ul>
  <li>
    <p>Updated the Raspbian install on our Raspberry Pi by running 
<code>apt-get update &amp;&amp; apt-get upgrade</code>  This took some hours, must have 
been quite a while since we did it!</p>
  </li>
  <li>
    <p>Enabled SPI using <code>raspi-config</code>.  What this actually seems to do is make 
sure the spi kernel module is installed.</p>
  </li>
</ul>

<p><code>sh
pi@raspberrypi ~ $ lsmod |grep spi
regmap_spi              1897  1 snd_soc_core
spi_bcm2708             4728  0
</code></p>

<ul>
  <li>Installed the PiFace Python modules <code>apt-get install python3-pifacecad</code>.
It’s nice that it is included in the Raspbian repos and can be installed so easily.</li>
</ul>

<h2 id="first-test">First Test</h2>

<p>The best idea is always to test using some code written by someone else
so that you know you have everything setup correctly.  Fortunately there is
a nice sysinfo sample provided.</p>

<p><code>sh
pi@raspberrypi ~ $ python3 /usr/share/doc/python3-pifacecad/examples/sysinfo.py
</code></p>

<p><img src="Sysinfo.jpg" alt="Sysinfo Demo" /></p>

<p>That works perfectly.  Time to dive into python and see what the api is like.</p>

<h2 id="hello-world-using-the-python-shell">Hello World Using The Python Shell</h2>

<p><code>py
pi@raspberrypi ~ $ python3
Python 3.2.3 (default, Mar  1 2013, 11:53:50)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import pifacecad as p
&gt;&gt;&gt; cad = p.PiFaceCAD()
&gt;&gt;&gt; cad.lcd.backlight_on()
&gt;&gt;&gt; cad.lcd.write("Hello World!")
</code></p>

<p><img src="HelloWorld.jpg" alt="Hello World" /></p>

<p>Pretty simple!  It took me much longer than this to get one of these
displays working on Arduino the first time I tried it.  But a lot of 
that was sorting out the wiring!  Thats one good reason to get a 
PiFace instead of wiring up your own display.</p>

<h2 id="something-a-bit-fancier">Something A Bit Fancier</h2>

<p>Ok, let’s try something a bit more tricky.  There are api commands to
move the cursor around and to hide the cursor, so let’s have a go with those.</p>

<p><code>py
pi@raspberrypi ~ $ python3
Python 3.2.3 (default, Mar  1 2013, 11:53:50)
[GCC 4.6.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import pifacecad as p
&gt;&gt;&gt; cad = p.PiFaceCAD()
&gt;&gt;&gt; cad.lcd.backlight_on()
&gt;&gt;&gt; cad.lcd.clear()
&gt;&gt;&gt; cad.lcd.set_cursor(5,0)
&gt;&gt;&gt; cad.lcd.write("Swindon")
&gt;&gt;&gt; cad.lcd.set_cursor(5,1)
&gt;&gt;&gt; cad.lcd.write("Hackspace")
&gt;&gt;&gt; cad.lcd.cursor_off()
&gt;&gt;&gt; cad.lcd.blink_off()
</code></p>

<p>A few points to note here.  For the non-programmers out there, computers count 
from zero, so “5” is actually the 6th position along and “0” is the first row. 
Interesting that you have to call both <code>cursor_off()</code> and <code>blink_off()</code> to totally 
get rid of the cursor, but that could be useful in certain situations.</p>

<p><img src="Hackspace.jpg" alt="Swindon Hackspace" /></p>

<h2 id="custom-bitmaps">Custom Bitmaps</h2>

<p>It would be nice if I could get the Swindon Hackspace logo on there too 
using the custom bitmap support.  From the 
<a href="http://piface.github.io/pifacecad/creating_custom_bitmaps.html">documentation</a>
it doesn’t look too difficult,  there is a <a href="http://www.quinapalus.com/hd44780udg.html">page for generating the codes</a> 
to create characters that is linked to from the documentation.  If you’re familiar with
setting bits in bytes it’s fairly easy to see what is going on; if you want the
right most pixel to be on, add 1, the second from the right, add 2, third
from the right add 4, fourth from the right, add 8, fifth from the right
add 16.  Do this for each line and you have the 8 values you need to pass 
into the <code>LCDBitmap()</code> function.</p>

<p>However there isn’t really enough room to get the hackspace logo in a single 
character so let’s try using more than one.  No mention of how many custom 
characters you are allowed in the PiFace docs, but the designer page about 
the HD44780 says you can have up to eight.  If we had 3x2 that would give us 
(5+5+5) x (8+8) = 15x16 pixels to play with.  That’s a nice square-ish shape and 
uses 6 custom characters so could work.  </p>

<p>I created a new image in Gimp that is 15x16 pixels, zoom in to 1600% and 
started designing by filling in pixels.  I then “split” this into six by using
the select tool to draw round each group of 5x8 pixels and copied it into
the online designer to generate the codes.  Lazy I know, I could work out
those numbers myself!</p>

<p>My first attempt didn’t look so great because of where the physical gaps 
between the characters on the display fell, but a bit of tweaking and I ended 
up with something like this:</p>

<p><code>py
&gt;&gt;&gt; sh = p.LCDBitmap([3,7,14,12,24,24,31,31])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(0, sh)
&gt;&gt;&gt; sh = p.LCDBitmap([31,31,0,27,27,27,31,31])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(1, sh)
&gt;&gt;&gt; sh = p.LCDBitmap([24,28,14,7,3,0,0,0])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(2, sh)
&gt;&gt;&gt; sh = p.LCDBitmap([0,0,0,24,28,14,7,3])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(3, sh)
&gt;&gt;&gt; sh = p.LCDBitmap([31,31,27,27,27,0,31,31])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(4, sh)
&gt;&gt;&gt; sh = p.LCDBitmap([31,31,3,3,6,14,28,24])
&gt;&gt;&gt; cad.lcd.store_custom_bitmap(5, sh)
</code></p>

<p>That code loads six custom characters into memory locations zero to five.
Now all we need to do is write them out to the display.  It might be wise 
to turn the cursor back on at this point to see where we are writing to:</p>

<p><code>py
&gt;&gt;&gt; cad.lcd.cursor_on()
&gt;&gt;&gt; cad.lcd.blink_on()
&gt;&gt;&gt; cad.lcd.set_cursor(1,0)
</code></p>

<p>Note that the cursor doesn’t reappear until you move it somewhere. Time 
to write out the logo and finally hide the cursor again.</p>

<p><code>py
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(0)
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(1)
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(2)
&gt;&gt;&gt; cad.lcd.set_cursor(1,1)
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(3)
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(4)
&gt;&gt;&gt; cad.lcd.write_custom_bitmap(5)
&gt;&gt;&gt;
&gt;&gt;&gt; cad.lcd.cursor_off()
&gt;&gt;&gt; cad.lcd.blink_off()
</code></p>

<p><img src="HackspaceLogo.jpg" alt="Custom Bitmaps" /></p>

<p>A pretty pleasing result for an hour of playing around in the Python
shell.</p>

<p>Interestingly, if you redefine one of the custom bitmaps by calling 
<code>store_custom_bitmap()</code> while it is on the display, it changes immediately 
without you having to rewrite it using <code>write_custom_bitmap()</code>.  This 
could be a neat way to have animated characters.  It does mean that 
you really are limited to the 8 it supports though, and you can’t 
“cheat” by defining one, writing it to the display and then re-defining it.</p>

<h2 id="errors">Errors</h2>

<p>If you do try to access or create more custom bitmaps than you should 
you get a nice friendly error message, which is good to know.  It’s always
reassuring that a library is decently written when it provides nice error
messages.</p>

<p>```py
»&gt; cad.lcd.write_custom_bitmap(8)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "/usr/lib/python3/dist-packages/pifacecad/lcd.py", line 458, in write_custom_bitmap
	self.char_bank_in_range_or_error(char_bank)
  File "/usr/lib/python3/dist-packages/pifacecad/lcd.py", line 492, in char_bank_in_range_or_error
	cgramaddr=char_bank,
Exception: There are only 8 custom characters (You tried to access 8).</module></stdin></p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>cad.lcd.store_custom_bitmap(8, sh)
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
  File "/usr/lib/python3/dist-packages/pifacecad/lcd.py", line 474, in store_custom_bitmap
	self.char_bank_in_range_or_error(char_bank)
  File "/usr/lib/python3/dist-packages/pifacecad/lcd.py", line 492, in char_bank_in_range_or_error
	cgramaddr=char_bank,
Exception: There are only 8 custom characters (You tried to access 8).
```</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>

<h2 id="and-finally">And Finally…</h2>

<p>Given I only know the basics in Python (though I do code in other languages)
it’s pretty easy to get started with the PiFace and make it do some cool stuff.
It seems like it should be fairly easy to get it doing something useful with
the 3D printer.  More on that later….</p>

<p>Thanks go to <a href="http://uk.farnell.com/">Farnell / Element14</a> for supplying the PiFace
Control and Display board.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diy Radiator Booster]]></title>
    <link href="http://swindon.hackspace.org.uk/blog/diy-radiator-booster/"/>
    <updated>2013-10-25T18:05:00+01:00</updated>
    <id>http://swindon.hackspace.org.uk/blog/diy-radiator-booster</id>
    <content type="html"><![CDATA[<p>Central heating is a great invention and radiators generally do a 
good job of pumping out heat into a room.  Sometimes however due
to the layout of the room or positioning of the radiator it
doesn’t quite work as well as it could.  I have a room like this
and decided to go for a bit of a DIY solution.</p>

<!-- more -->

<p><img src="2.jpg" alt="Booster in place" /></p>

<p>My kitchen and dining room are one and also open to the stairs 
and landing.  With only one big raditor in the whole space most 
of the heat tends to rise and go up the stairs rather than circulating
in the rooms, meaning it always feels chilly.  There are various
<a href="http://www.nigelsecostore.com/acatalog/Radiator_Booster.html">commercial radiator boosters</a>
available but some reviews say they are noisy and they all sit on top of
the radiator which would mean moving it everytime I closed the 
curtains.  So I decided to design and build my own.</p>

<h2 id="the-idea">The Idea</h2>

<p>Take a standard quick PC fan, mount it to the bottom of the radiator, 
create a duct to direct the air across the floor and build a circuit
to turn it on automatically when the radiator gets warm.</p>

<h2 id="the-fan">The Fan</h2>

<p>Rather conveniently the gap between the front and back panels of 
the double radiator is just over 80mm meaning a standard PC fan
will fit nicely.  I bought a Be Quiet Silentwings Pure 80mm fan
like this one from <a href="http://www.ebuyer.com/409820-be-quiet-silentwings-pure-80mm-bl041">ebuyer</a>
which turned out to be pretty much silent when running.</p>

<h2 id="the-circuit">The Circuit</h2>

<p>I needed a circuit that would switch on the 12V fan when the 
radiator warmed up and turn it off again when it cooled down.
I could have gone down the microcontroller route to do this, but 
it seemed like a fairly simple circuit with a temperature
sensor and a relay should be able to do the job.  After some time
googling I found exactly what I needed.  <a href="http://www.escol.com.my/Projects/Project-03%28Thermostat-1%29/Proj-03.html">This site</a> 
has done an excellent job of describing how to make a temperature 
controlled relay using a few basic electronics componets.  There are
kits for sale, but I chose to just buy the components and assemble
them on some strip board.</p>

<p><img src="3.jpg" alt="Circuit" /></p>

<h2 id="the-ducting">The Ducting</h2>

<p>Initially I was planning on using some thin plywood or something
similar for the ducting.  However a few members of the hackspace
have 3D printers and kindly offered to print something for me.
So following on from a talk given at the hackspace some months
ago about how to <a href="https://groups.google.com/forum/#!topic/swindon-hackspace/PvvfdYWvo0c">use openscad</a> 
I decided to try and design a 3D printable enclosure.</p>

<p><img src="4.jpg" alt="Ducting" /></p>

<p>It took a couple of attempts to get something that was printable, 
but with the help and advice of other members I managed to design
a nice curved duct with some fins and small box to mount the electronics 
in.  The design is available on <a href="http://www.thingiverse.com/thing:168527">thingiverse</a>.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>With all the parts made and colder weather fast approaching I 
assembled everything and wired it up using and old 12V power
supply I had lying around.  Tuning the temperature at which the
fan comes on is as simple as adjusting the potentiometer
on the circuit board.  The fan doesn’t blast hot air out like a
fan heater does, but it does produce a gentle breeze of warm
air across the floor.  Whether it has made a huge difference
is hard to tell so far but I don’t think it can hurt.</p>

<p><img src="5.jpg" alt="Complete" /></p>
]]></content>
  </entry>
  
</feed>
